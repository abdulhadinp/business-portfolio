---
title: "TypeScript Patterns for Large Applications"
description: "Proven TypeScript patterns that scale well in large codebases."
date: "2024-01-05"
author: "Abdul Hadi"
tags: ["TypeScript", "Patterns", "Architecture", "Best Practices"]
published: true
---

# TypeScript Patterns for Large Applications

As applications grow in size and complexity, maintaining code quality and developer productivity becomes increasingly challenging. TypeScript provides powerful tools for building scalable applications, but using the right patterns is essential for long-term success. This article explores proven TypeScript patterns that work well in large codebases.

## 1. Type-Driven Development

### Strict Type Configuration
Start with strict TypeScript configuration:

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

### Domain-Driven Types
Create types that reflect your business domain:

```typescript
// Primitive types
type UserId = string & { readonly brand: unique symbol }
type Email = string & { readonly brand: unique symbol }
type ProductId = string & { readonly brand: unique symbol }

// Factory functions
function createUserId(id: string): UserId {
  return id as UserId
}

function createEmail(email: string): Email {
  if (!isValidEmail(email)) {
    throw new Error('Invalid email format')
  }
  return email as Email
}
```

## 2. Architecture Patterns

### Repository Pattern
Implement repository pattern for data access:

```typescript
interface Repository<T, ID> {
  findById(id: ID): Promise<T | null>
  findAll(): Promise<T[]>
  create(entity: Omit<T, 'id'>): Promise<T>
  update(id: ID, entity: Partial<T>): Promise<T>
  delete(id: ID): Promise<void>
}

interface UserRepository extends Repository<User, UserId> {
  findByEmail(email: Email): Promise<User | null>
  findActive(): Promise<User[]>
}

class SqlUserRepository implements UserRepository {
  async findById(id: UserId): Promise<User | null> {
    // Implementation
  }
  
  // ... other methods
}
```

### Service Layer Pattern
Separate business logic from data access:

```typescript
interface UserService {
  createUser(userData: CreateUserData): Promise<User>
  authenticateUser(email: Email, password: string): Promise<User | null>
  updateUserProfile(userId: UserId, profile: UserProfile): Promise<User>
}

class UserServiceImpl implements UserService {
  constructor(
    private userRepository: UserRepository,
    private emailService: EmailService,
    private passwordHasher: PasswordHasher
  ) {}
  
  async createUser(userData: CreateUserData): Promise<User> {
    const hashedPassword = await this.passwordHasher.hash(userData.password)
    const user = await this.userRepository.create({
      ...userData,
      password: hashedPassword
    })
    
    await this.emailService.sendWelcomeEmail(user.email)
    return user
  }
}
```

## 3. Error Handling Patterns

### Result Pattern
Use Result type for better error handling:

```typescript
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E }

async function safeOperation<T>(
  operation: () => Promise<T>
): Promise<Result<T>> {
  try {
    const data = await operation()
    return { success: true, data }
  } catch (error) {
    return { success: false, error: error as Error }
  }
}

// Usage
const result = await safeOperation(() => userRepository.findById(userId))

if (result.success) {
  // Handle success
  console.log(result.data)
} else {
  // Handle error
  console.error(result.error.message)
}
```

### Custom Error Types
Create specific error types:

```typescript
abstract class AppError extends Error {
  abstract readonly code: string
  abstract readonly statusCode: number
}

class ValidationError extends AppError {
  readonly code = 'VALIDATION_ERROR'
  readonly statusCode = 400
  
  constructor(message: string, public readonly field?: string) {
    super(message)
  }
}

class NotFoundError extends AppError {
  readonly code = 'NOT_FOUND'
  readonly statusCode = 404
  
  constructor(resource: string, id: string) {
    super(`${resource} with id ${id} not found`)
  }
}
```

## 4. State Management Patterns

### Type-Safe State Management
Use type-safe state management:

```typescript
interface AppState {
  user: UserState
  products: ProductState
  ui: UIState
}

interface UserState {
  currentUser: User | null
  isLoading: boolean
  error: string | null
}

type UserAction =
  | { type: 'SET_USER'; payload: User }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }

function userReducer(state: UserState, action: UserAction): UserState {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, currentUser: action.payload, error: null }
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload }
    case 'SET_ERROR':
      return { ...state, error: action.payload, isLoading: false }
    default:
      return state
  }
}
```

## 5. API Patterns

### Type-Safe API Clients
Create type-safe API clients:

```typescript
interface ApiClient {
  get<T>(url: string): Promise<T>
  post<T>(url: string, data: unknown): Promise<T>
  put<T>(url: string, data: unknown): Promise<T>
  delete(url: string): Promise<void>
}

class TypedApiClient implements ApiClient {
  constructor(private baseUrl: string) {}
  
  async get<T>(endpoint: string): Promise<T> {
    const response = await fetch(`${this.baseUrl}${endpoint}`)
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    return response.json()
  }
  
  // ... other methods
}

// Usage with typed endpoints
interface UserEndpoints {
  '/users': User[]
  '/users/:id': User
  '/users/:id/profile': UserProfile
}

class UserServiceClient {
  constructor(private api: TypedApiClient) {}
  
  async getUsers(): Promise<User[]> {
    return this.api.get<User[]>('/users')
  }
  
  async getUserById(id: UserId): Promise<User> {
    return this.api.get<User>(`/users/${id}`)
  }
}
```

## 6. Testing Patterns

### Type-Safe Testing
Use type-safe test utilities:

```typescript
interface TestDataFactory<T> {
  create(overrides?: Partial<T>): T
  createMany(count: number, overrides?: Partial<T>): T[]
}

class UserFactory implements TestDataFactory<User> {
  create(overrides: Partial<User> = {}): User {
    return {
      id: createUserId('test-id'),
      email: createEmail('test@example.com'),
      name: 'Test User',
      createdAt: new Date(),
      ...overrides
    }
  }
  
  createMany(count: number, overrides: Partial<User> = {}): User[] {
    return Array.from({ length: count }, () => this.create(overrides))
  }
}

// Usage in tests
const userFactory = new UserFactory()
const testUser = userFactory.create({ name: 'Custom User' })
```

## 7. Configuration Patterns

### Type-Safe Configuration
Create type-safe configuration:

```typescript
interface DatabaseConfig {
  host: string
  port: number
  username: string
  password: string
  database: string
}

interface AppConfig {
  database: DatabaseConfig
  redis: {
    url: string
    keyPrefix: string
  }
  jwt: {
    secret: string
    expiresIn: string
  }
}

function validateConfig(config: unknown): AppConfig {
  if (!config || typeof config !== 'object') {
    throw new Error('Invalid configuration')
  }
  
  // Add comprehensive validation
  return config as AppConfig
}

const appConfig = validateConfig(process.env)
```

## 8. Migration Strategies

### Gradual Typing
For existing JavaScript codebases:
```typescript
// Start with any types
interface LegacyUser {
  [key: string]: any
}

// Gradually add specific types
interface TypedUser {
  id: string
  name: string
  email?: string
}

// Use type guards for migration
function isTypedUser(user: unknown): user is TypedUser {
  return (
    typeof user === 'object' &&
    user !== null &&
    'id' in user &&
    'name' in user
  )
}
```

## Conclusion

These patterns provide a solid foundation for building large-scale TypeScript applications. The key is to be consistent, maintainable, and always prioritize type safety. As your application grows, these patterns will help you maintain code quality and developer productivity.

Remember that patterns are tools, not rules. Adapt them to your specific needs and always consider the trade-offs. The goal is to write code that is maintainable, testable, and scalable.

Happy coding with TypeScript!
